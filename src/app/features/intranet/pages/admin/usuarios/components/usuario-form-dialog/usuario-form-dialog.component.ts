import {
	ActualizarUsuarioRequest,
	CrearUsuarioRequest,
	ROLES_USUARIOS_ADMIN,
	RolUsuarioAdmin,
	SalonProfesor,
	UserProfileService,
} from '@core/services';
import {
	ChangeDetectionStrategy,
	Component,
	computed,
	effect,
	inject,
	input,
	output,
	signal,
} from '@angular/core';

import { ButtonModule } from 'primeng/button';
import { Checkbox } from 'primeng/checkbox';
import { CommonModule } from '@angular/common';
import { DatePickerModule } from 'primeng/datepicker';
import { DialogModule } from 'primeng/dialog';
import { FormFieldErrorComponent } from '@shared/components';
import { FormsModule } from '@angular/forms';
import { InputTextModule } from 'primeng/inputtext';
import { PasswordModule } from 'primeng/password';
import { SelectModule } from 'primeng/select';
import { TableModule } from 'primeng/table';
import { ToggleSwitch } from 'primeng/toggleswitch';
import { UppercaseInputDirective } from '@shared/directives';

export type UsuarioFormData = Partial<CrearUsuarioRequest & ActualizarUsuarioRequest>;

export interface FormValidationErrors {
	dniError: string | null;
	correoError: string | null;
	correoApoderadoError: string | null;
	nombreApoderadoError: string | null;
	telefonoApoderadoError: string | null;
}

/**
 * Componente presentacional para el dialog de formulario de usuario
 * Edición y creación de usuarios
 */
@Component({
	selector: 'app-usuario-form-dialog',
	standalone: true,
	imports: [
		CommonModule,
		FormsModule,
		DialogModule,
		ButtonModule,
		InputTextModule,
		SelectModule,
		ToggleSwitch,
		PasswordModule,
		DatePickerModule,
		FormFieldErrorComponent,
		TableModule,
		UppercaseInputDirective,
		Checkbox,
	],
	templateUrl: './usuario-form-dialog.component.html',
	styleUrl: './usuario-form-dialog.component.scss',
	changeDetection: ChangeDetectionStrategy.OnPush,
})
export class UsuarioFormDialogComponent {
	private userProfile = inject(UserProfileService);

	// * Inputs from parent (dialog state + form data).
	readonly visible = input.required<boolean>();
	readonly isEditing = input.required<boolean>();
	readonly formData = input.required<UsuarioFormData>();
	readonly errors = input.required<FormValidationErrors>();
	readonly isFormValid = input.required<boolean>();
	readonly salones = input<SalonProfesor[]>([]);

	// * Outputs for dialog actions and field updates.
	readonly visibleChange = output<boolean>();
	readonly fieldChange = output<{ field: string; value: unknown }>();
	readonly save = output<void>();
	readonly cancelDialog = output<void>();

	// * Options for role selector.
	readonly rolesSelectOptions = ROLES_USUARIOS_ADMIN.map((r) => ({ label: r, value: r }));

	// * Only selected roles can manually edit passwords.
	readonly allowEditPasswordRoles = ['Director', 'Asistente Administrativo'];

	// * Local state for two-step salon selector (grado -> seccion).
	readonly _gradoSeleccionado = signal<string | null>(null);
	readonly _seccionSeleccionada = signal<string | null>(null);

	// * Only allowed roles can edit password.
	readonly canEditPassword = computed(() =>
		this.allowEditPasswordRoles.includes(this.userProfile.userRole()),
	);

	// #region Validaciones de contraseña

	/**
	 * Obtiene la contraseña actual del formulario
	 */
	private readonly _contrasena = computed(() => {
		const pwd = this.formData().contrasena;
		return typeof pwd === 'string' ? pwd : '';
	});

	/**
	 * Valida longitud mínima de 8 caracteres
	 */
	readonly contrasenaMinLengthValid = computed(() => {
		const pwd = this._contrasena();
		return pwd.length >= 8;
	});

	/**
	 * Valida al menos una mayúscula
	 */
	readonly contrasenaHasUppercase = computed(() => {
		const pwd = this._contrasena();
		return /[A-Z]/.test(pwd);
	});

	/**
	 * Valida al menos una minúscula
	 */
	readonly contrasenaHasLowercase = computed(() => {
		const pwd = this._contrasena();
		return /[a-z]/.test(pwd);
	});

	/**
	 * Valida al menos un número
	 */
	readonly contrasenaHasNumber = computed(() => {
		const pwd = this._contrasena();
		return /[0-9]/.test(pwd);
	});

	/**
	 * Valida al menos un carácter especial
	 */
	readonly contrasenaHasSpecialChar = computed(() => {
		const pwd = this._contrasena();
		return /[!@#$%^&*(),.?":{}|<>]/.test(pwd);
	});

	/**
	 * Indica si todas las validaciones de contraseña son válidas
	 */
	readonly contrasenaValidationsValid = computed(() => {
		const pwd = this._contrasena();
		// Si no hay contraseña, no hay error (puede ser opcional según el contexto)
		if (!pwd) return true;

		return (
			this.contrasenaMinLengthValid() &&
			this.contrasenaHasUppercase() &&
			this.contrasenaHasLowercase() &&
			this.contrasenaHasNumber() &&
			this.contrasenaHasSpecialChar()
		);
	});

	autoGeneratedValue = computed(() => {
		// En edición, usar la contraseña real del backend
		if (this.isEditing()) {
			return this.formData().contrasena ?? '';
		}

		// En creación, auto-generar desde apellido + DNI
		const apellido = (this.formData().apellidos ?? '').trim();
		const dniRaw = (this.formData().dni ?? '').trim();
		const pref = apellido.slice(0, 2).toUpperCase();
		const digits = dniRaw.replace(/\D/g, '');
		const suf = digits.slice(-4);

		if (pref.length < 2 || suf.length < 4) return '';

		return `${pref}${suf}`;
	});

	// * Role helpers for conditional sections.
	get isEstudiante(): boolean {
		return this.formData().rol === 'Estudiante';
	}

	get isProfesor(): boolean {
		return this.formData().rol === 'Profesor';
	}

	get needsSalon(): boolean {
		return this.isProfesor || this.isEstudiante;
	}

	// Helper para tipar correctamente el rol
	get rolValue(): RolUsuarioAdmin | undefined {
		return this.formData().rol as RolUsuarioAdmin | undefined;
	}

	// * Format display of section codes.
	private formatSeccion(seccion: string): string {
		return seccion === 'V' ? 'Verano' : seccion;
	}

	// * Grade options derived from salon list.
	readonly gradosOptions = computed(() => {
		const salones = this.salones();
		const gradosUnicos = new Set<string>();
		const result: { label: string; value: string }[] = [];

		salones.forEach((s) => {
			if (!gradosUnicos.has(s.grado)) {
				gradosUnicos.add(s.grado);
				result.push({ label: s.grado, value: s.grado });
			}
		});

		return result;
	});

	// * Section options derived from selected grade.
	readonly seccionesOptions = computed(() => {
		const grado = this._gradoSeleccionado();
		if (!grado) return [];

		const salones = this.salones();
		const seccionesDelGrado = salones
			.filter((s) => s.grado === grado)
			.map((s) => ({
				label: this.formatSeccion(s.seccion),
				value: s.seccion,
			}));

		return seccionesDelGrado;
	});

	// * Map selected grade/section to a salonId.
	readonly salonSeleccionado = computed(() => {
		const grado = this._gradoSeleccionado();
		const seccion = this._seccionSeleccionada();
		if (!grado || !seccion) return null;

		const salones = this.salones();
		return salones.find((s) => s.grado === grado && s.seccion === seccion) || null;
	});

	onVisibleChange(visible: boolean): void {
		this.visibleChange.emit(visible);
	}

	onFieldChange(field: string, value: unknown): void {
		this.fieldChange.emit({ field, value });
	}

	onGradoChange(grado: string | null): void {
		// * Clear section, salonId, and text fields when grade changes.
		this._gradoSeleccionado.set(grado);
		this._seccionSeleccionada.set(null);
		this.fieldChange.emit({ field: 'salonId', value: undefined });
		this.fieldChange.emit({ field: 'grado', value: undefined });
		this.fieldChange.emit({ field: 'seccion', value: undefined });
	}

	onSeccionChange(seccion: string | null): void {
		this._seccionSeleccionada.set(seccion);

		// * Map grado + seccion to salonId and text fields in the form.
		const salon = this.salonSeleccionado();
		if (salon) {
			this.fieldChange.emit({ field: 'salonId', value: salon.salonId });
			this.fieldChange.emit({ field: 'grado', value: salon.grado });
			this.fieldChange.emit({ field: 'seccion', value: salon.seccion });
		} else {
			this.fieldChange.emit({ field: 'salonId', value: undefined });
			this.fieldChange.emit({ field: 'grado', value: undefined });
			this.fieldChange.emit({ field: 'seccion', value: undefined });
		}
	}

	// Sincronizar grado y sección cuando cambia formData.salonId (edición)
	private readonly _syncGradoSeccion = effect(() => {
		const salonId = this.formData().salonId;
		const salones = this.salones();
		if (salonId && salones.length > 0) {
			const salon = salones.find((s) => s.salonId === salonId);
			if (salon) {
				this._gradoSeleccionado.set(salon.grado);
				this._seccionSeleccionada.set(salon.seccion);
			}
		}
	});

	onSave(): void {
		this.save.emit();
	}

	onCancel(): void {
		this.cancelDialog.emit();
	}
	// #endregion
}
